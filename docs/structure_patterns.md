# Dart Project Structure & Design Patterns

This section provides recommendations for organizing Dart projects and applying common design patterns.

## 1. Standard Package Structure

A well-organized package structure improves maintainability and clarity.

- **General Package Layout**:
  ```
  /
  ├── lib/                   # Contains all public library code.
  │   ├── src/               # Contains private implementation details.
  │   │   ├── models/        # Data classes, enums.
  │   │   ├── data/          # Data sources (repositories, APIs, local storage).
  │   │   ├── domain/        # Business logic (use cases, services - if complex).
  │   │   ├── presentation/  # UI-related logic (controllers, state - for Flutter/web).
  │   │   └── utils/         # Common utility functions.
  │   └── my_package.dart    # Main library file exporting ONLY the public API from src/.
  ├── bin/                   # Executable scripts run via `dart run`.
  ├── test/                  # All test files (mirroring `lib/` structure).
  │   ├── unit/
  │   └── integration/
  ├── tool/                  # Developer utility scripts (build, format, analyze).
  ├── example/               # Example usage of the library/package.
  ├── benchmark/             # Performance benchmarks.
  ├── analysis_options.yaml  # Linter configuration.
  ├── dart_test.yaml         # Test runner configuration (optional).
  ├── dartdoc_options.yaml   # Documentation generator config (optional).
  ├── pubspec.yaml           # Package manifest.
  ├── LICENSE
  └── README.md              # Project description and usage.
  ```
- **`lib/src/` Convention**: Code inside `lib/src/` is considered private to the package. Other packages should NOT import directly from `lib/src/`.
- **`lib/my_package.dart` Exports**: The main library file (e.g., `lib/my_package.dart`) should explicitly `export` only the symbols intended for public use from the `lib/src/` directory. Use `show` and `hide` combinators on exports for fine-grained control.
  ```dart
  // lib/my_package.dart
  library my_package;

  // Export public models
  export 'src/models/user.dart';
  export 'src/models/product.dart';

  // Export public services/functions
  export 'src/domain/auth_service.dart';
  export 'src/utils/formatter.dart' show formatDate; // Only export specific utility

  // DO NOT export implementation details or entire files from src/ unless intended.
  ```
- **Feature-First vs. Layer-First**:
    - For smaller packages/apps, a layer-first approach (like the example above) is often sufficient.
    - For larger applications, consider organizing by feature within `lib/src/`:
      ```
      lib/src/
      ├── features/
      │   ├── auth/
      │   │   ├── data/
      │   │   ├── domain/
      │   │   ├── presentation/
      │   │   └── models/
      │   ├── product/
      │   │   └── ...
      │   └── ...
      ├── core/          # Shared core logic, utils, models across features
      │   ├── utils/
      │   ├── models/
      │   └── ...
      └── ...
      ```
      Choose the structure that best suits the project's complexity.

## 2. Design Patterns

Leverage common design patterns to create maintainable and scalable code.

- **Dependency Injection (DI)**:
    - **Why**: Decouples components, improves testability, makes code easier to manage.
    - **Tool**: `riverpod` is the preferred solution. Use providers to make dependencies (services, repositories) available throughout the application (especially in Flutter). Define providers in dedicated files (e.g., `lib/src/core/providers.dart` or feature-specific provider files).
- **Repository Pattern**:
    - **Why**: Abstracts data access logic. Provides a clean API for fetching/saving data, hiding the underlying source (API, database, cache).
    - **Implementation**: Define abstract `Repository` interfaces (e.g., `UserRepository`). Implement concrete repositories (e.g., `ApiUserRepository`, `LocalStorageUserRepository`) that depend on data sources (e.g., `HttpClient`, `SharedPreferences`). Use DI (Riverpod) to provide the concrete implementation.
- **Result Type / Either Pattern**:
    - **Why**: Explicitly handle success and failure cases without relying solely on exceptions for control flow. Improves predictability.
    - **Tool**: `package:multiple_result` or implement a custom `Result` sealed class/enum. Functions that can fail should return `Future<Result<SuccessType, ErrorType>>`.
- **Builder Pattern**:
    - **Why**: Useful for constructing complex objects step-by-step, especially immutable ones.
    - **Implementation**: Can be implemented manually or often handled implicitly by code generation tools (like the `copyWith` methods generated by `copy_with_extension`).
- **State Management (Flutter)**:
    - **Tool**: `riverpod` (annotation/generator style).
    - **Approach**: Use different provider types (`Provider`, `FutureProvider`, `NotifierProvider`, etc.) based on the type of state (simple dependency, async data, mutable state). Keep UI widgets focused on presentation, delegating state logic to Riverpod Notifiers/Providers. Combine with `flutter_hooks` for local widget state/lifecycle management.

## 3. Error Handling

- **Use Typed Exceptions**: Define custom `Exception` subclasses for specific error conditions (e.g., `NetworkException`, `AuthenticationException`). Avoid throwing generic `Exception` or strings.
- **Prefer Result Types**: For predictable errors (e.g., validation failure, resource not found), return a `Result` type instead of throwing an exception. Reserve exceptions for truly exceptional/unrecoverable situations.
- **Catch Specific Exceptions**: When using `try-catch`, catch the most specific exception type possible. Avoid catching generic `Exception` or `Object` unless absolutely necessary (and rethrow if appropriate).
- **Logging**: Implement structured logging. Use a logging framework (e.g., `package:logging`) and include relevant context (timestamps, error details, stack traces) in log messages. Catch errors at application boundaries (e.g., UI event handlers, API endpoints) and log them appropriately.
- **Stack Traces**: Include `StackTrace` when catching and logging exceptions (`catch (e, s) { log.error('Error occurred', e, s); }`).

## 4. Asynchronous Code

- **`async`/`await`**: Use `async` and `await` for clear, readable asynchronous code.
- **Error Handling**: Always handle potential errors in async operations using `try-catch` around `await` or `.catchError()` on Futures. Unhandled async errors can crash the application or lead to silent failures. Use `unawaited_futures` lint to detect unawaited futures.
- **`Future` vs. `Stream`**: Use `Future` for operations that produce a single result (or error). Use `Stream` for sequences of events over time.
- **Cancellation**: For long-running operations, consider implementing cancellation mechanisms if needed (e.g., using `StreamSubscription.cancel()`, passing cancellation tokens).